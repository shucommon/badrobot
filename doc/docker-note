CloudMan https://mp.weixin.qq.com/s/7o8QxGydMTUe4Q7Tz46Diw?

1 Docker ecosystem
    container core technology
        container standard  -> Open Container Initiative(OCI)
            runtime spec
            image format spec

        container runtime
            lxc  linux originate, container use this at beginning
            runc docker developped, it's default now
            rkt  developped by CoreOS

        container managerment tools
            lxd -> lxc
            docker engine -> runc
                deamon
                cli
            rkt cli -> rkt

        container define tools
            docker image : template of docker container, runtime depend on docker image to create container
            dockerfile: contain cmds to create docker image
            ACI(App Container Image): image of rtk by CoreOS

        Registries
            Docker Registry: for enterprise
            Docker Hub (https://hub.docker.com) : public registry
            Quay.io(https://quay.io/) : public registry

        container OS - OS specific for running container
            coreos
            atoic
            ubuntu core

    container platform technology - make container running as cluster in distribute system
        container orchestration(编排) engine - container management, schedule, cluster define, service discover, form a microservice application
            docker swarm - developped by docker
            kubernetes - by Google, support docker, CoreOS container
            mesos+marathon

        container manage platform - contruct based on container orchestration
            Rancher
            ContainerShip

        PaaS based on container
            Deis
            Flynn
            Dokku
        
    container support technology
        Docker network
            docker network
            flannel
            weave
            calico

        Service discover - save microservice latest info in cluster(ip/port), provide API for outside
            etcd
            consul
            zookeeper

        Monitor
            docker ps/top/stats
            docker stats API - HTTP
            sysdig
            cAdvisor/Heapster
            Weave Scope

        Data manage - migrate between host
            Flocker

        Log manage
            docker logs
            logspout

        Safety
            OpenSCAP

2. Install docker - https://docs.docker.com/install/
    Update the apt package index:
        $ sudo apt-get update

    Install packages to allow apt to use a repository over HTTPS:
        $ sudo apt-get install \
            apt-transport-https \
            ca-certificates \
            curl \
            gnupg-agent \
            software-properties-common

    Add Docker’s official GPG key:
        $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -

    Verify that you now have the key with the fingerprint 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88, by searching for the last 8 characters of the fingerprint.
        $ sudo apt-key fingerprint 0EBFCD88
        
        pub   rsa4096 2017-02-22 [SCEA]
              9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88
        uid           [ unknown] Docker Release (CE deb) <docker@docker.com>
        sub   rsa4096 2017-02-22 [S]

    Use the following command to set up the stable repository.
        $ sudo add-apt-repository \
           "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
           $(lsb_release -cs) \
           stable"

    Update the apt package index.
        $ sudo apt-get update

    Install the latest version of Docker CE and containerd, or go to the next step to install a specific version:
        $ sudo apt-get install docker-ce docker-ce-cli containerd.io

    Verify that Docker CE is installed correctly by running the hello-world image.
        $ sudo docker run hello-world

3. Docker construct in details
    Docker Client

    Docker server - Docker daemon
        docker status:
            $ systemctl status docker.service
        restart daemon:
            $ systemctl daemon-reload
            $ systemctl restart docker.service 
        to allow remote client request:
            /etc/systemd/system/multi-user.target.wants/docker.service, add "-H tcp://0.0.0.0" after ExecStart to allow any IP
        communicate with remoete server(192.168.1.115):
            $ docker -H 192.168.1.115 info(command)        

    Docker registry - Image : template to create docker container
        $ docker build <docker-file> 

    Registry
        $ docker pull
        $ docker run

    Docker Container
        the runtime of docker image

    docker conponent cooperate
        $ docker run -d -p 80:80 httpd
        $ docker images [image_name]    -> list local downloaded images
        $ docker ps                     -> list running containers
        $ docker container ls           -> list running containers

4. Docker Image
    Dockerfile -> image describe file
        hello-world dockerfile:
            FROM scratch
            COPY hello /        ->copy file hello to /
            CMD ["/hello"]      ->when image run, exec /hello

    base image : build from scratch, such as Ubuntu/Debian/CentOS
        CentOS DockerFILE
            FROM scratch
            ADD centos-7-docker.tar.xz /
            CMD ["/bin/bash"]

    container rely on host kernel, can modify the kernel

    docker hierarchy
        FROM debian
        RUN apt-get install emacs
        RUN apt-get install apache2
        CMD ["/bin/bash"]
    
        when container start, a new writable layer is added to the top of the image, it's called "container layer", the left is "image layer"
        upper layer same name file will override lowwer layre file
        modify file: loop up from upper image to lowwer, the first match file will be copied to container layer
        delete file: also from upper layer
        copy-on-wirte - copy only when need modify

    Create docker image
        docker commit
            1. run container
                $ docker run -it ubuntu
            2. modify contaier
                $ apt-get install -y vim 
            3. save as new image 
                in host, run $ docker ps to get container name
                docker commit container_name image_name

        Dockerfile
            FROM ubuntu
            RUN apt-get update && apt-get install -y vim

            $docker build -t new_image_name .  -> . mean build context is current path, search Dockerfile in build content
            $docker build -t new_image_name . -f Dockerfile 
    
            $ docker history container
            $ docker build will try to use cache for exist container, using docker build --no-cache to avoid using cache

            FROM                -> specify base Image
            MAINTAINER          -> set Image auther 
            COPY                -> copy file from build context to Image
                COPY src dest
                COPY ["src", "dest"]
            ADD                 -> save with COPY, except that it will auto extract tar/zip/tgz/xz will copy to Image
            ENV                 -> set environment variable
                '''
                ENV MY_VERSION 1.3
                RUN apt-get install -y mypackage=$MY_VERSION
                '''
            EXPOSE              -> specify a PORT for the process in container
            VOLUME              -> claim file or folder as volume
            WORKDIR             -> set current work dir for subcmd(RUN/CMD/ENTRYPOINT/ADD/COPY)
            RUN                 -> run cmd in container
            CMD                 -> run when container start, only the last CMD have effective, CMD will be replaced by parameter after docker run 
            ENTRYPOINT          -> last one have effective, CMD or parameter after docker run will pass to ENTRYPOINT as parameter
                RUN execute cmd and create new Image layer, often used to install software
                CMD set default cmd and parameter to execute after container start. if docker run have parameters, CMD will be replaced
                ENTRYPOINT set cmd to run when container start, if CMD only have parameters, then the parameter will pass to ENTRYPOINT. if ENTRYPOINT using shell method, CMD or docker run parameter will be ignored

        Docker image name
            [image name] = [repository]:[tag]
            docker tag myimage-v1.9.1 myimage:1
            docker tag myimage-v1.9.1 myimage:1.9
            docker tag myimage-v1.9.1 myimage:1.9.1
            docker tag myimage-v1.9.1 myimage:latest

    Using public registry
        register account on Docker Hub
        $ docker login -u user_name  / password:
        $ docker tag httpd user_name/httpd:v1   -> set standard name:  [username]/xxx:tag
        $ docker push user_name/httpd:v1
        $ docker push user_name/httpd       -> push all image under same repository

    Configure personal registry
        $ docker run -d -p 5000:5000 -v /myregistry:/var/lib/registry registry:2        -> -d deamon -p map container port to host port -v map container /var/lib/registry to host /myregistry
        $ docker tag user_name/httpd:v1 registry.example.net:5000/user_name/httpd:v1    -> rename image to match registry  - [registry-host]:[port]/[username]/xxx
        $ docker push registry.example.net:5000/user_name/httpd:v1
        $ docker pull registry.example.net:5000/user_name/httpd:v1
            
    summary
        images    show image list
        history   show image create history
        commit    create new image from container
        build     construct new image from Dockerfile
        tag       set tag for image
        pull      download image from registry
        push      upload image to registry
        rmi       remove Docker host image -> only can delete image in host, not registry
        search    search Docker Hub image
